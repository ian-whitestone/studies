<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="d3.slider.css" />
<style>

body {
  margin: 0;
}

#points{
	width:100%;
	height:100%;
	position:relative;
	z-index:100;
}

#container {
  position: relative;
  overflow: hidden;
	background: #ddd;
}

.map {
  position: relative;
  overflow: hidden;
}

.layer {
  position: absolute;
}

.tile {
  pointer-events: none;
  position: absolute;
  width: 256px;
  height: 256px;
}

.parking_spot{
	opacity: 0.8;
	/*fill: black; fill is now defined based on infraction code*/
}

.parking_spot:hover{
	opacity: 0.5;
	fill: #ff8a00;
}

.info {
  position: absolute;
  bottom: 10px;
  left: 10px;
}


.d3-tip {
  line-height: 1.5;
  font-weight: bold;
	font-family: Helvetica, Arial, sans-serif;
	font-size:13px;
  padding: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 3px;
	position:relative;
	z-index:101;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 20px;
  width: 100%;
  line-height: .5;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}

/*#slider {
  /*margin: 20px 0 10px 20px;*/
  width: 1325px;
} */

</style>
<body>
  <script src="//d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/d3.geo.tile.v0.min.js"></script>
  <script src="d3.tip.js"></script>
  <script src="d3.slider.js"></script>


<div id="slider"></div>

<script>


var left_offset=300, //inherently sets the margin
    top_offset=100,
    width_margin=2*left_offset,
    margin=200,
    width = Math.max(960, window.innerWidth) - width_margin,
    height = Math.max(500, window.innerHeight) - margin;
    prefix = prefixMatch(["webkit", "ms", "Moz", "O"]);

var default_year=2011;//start at 2011
var to=[-79.38558, 43.7020];

// Initialize slider
var slider_axis = d3.svg.axis().orient("bottom").tickFormat(d3.format("d")).ticks(8);
var slider = d3.slider().axis(slider_axis).min(2008).max(2015)
            .step(1).value(default_year)
            .on("slide", function(evt, year) {
              //define these once csv data

              data=raw_data.filter(function(d) {
                      return d.year == year;});

              max = d3.max(data, function(d) { return d.fine_sum; });
              min = d3.min(data, function(d) { return d.fine_sum; });

              console.log("max: ",max);
              //redefine scale based on new data
              rscale = d3.scale.linear()
              .domain([min,max])
              .range([0.00000018,0.00000852]); //custom max/zoom.scale & min/zoom.scale values

                add_circles(data);
            });

// Render the slider in the div
d3.select('#slider')
.style("width",width+"px")
.style("top",top_offset - 30 +"px")
.style("left",left_offset + "px")
.call(slider);


var raw_data;
var rscale;


d3.csv("top_spots.csv", function(error, dataset)
      {
        // Convert strings to numbers.
          dataset.forEach(function(d) {
            d.fine_sum = +d.fine_sum;
            d.infraction_code=+d.infraction_code;
            d.count=+d.count;
            d.mean_hour=+d.mean_hour;
          });

        raw_data=dataset;


        dataset=dataset.filter(function(d) {
                return d.year == default_year;}); //eventually need this to be reactive based on transition/user selection

        // dataset=dataset.filter((function(d) {
        //         return d.infraction_code == 15;}));
        //define these once csv data is loaded and filtered

        max = d3.max(dataset, function(d) { return d.fine_sum; });
        min = d3.min(dataset, function(d) { return d.fine_sum; });

        console.log("max: ",max);

        rscale = d3.scale.linear()
        .domain([min,max])
        .range([0.00000018,0.00000852]); //custom max/zoom.scale & min/zoom.scale values

        add_circles(dataset);
      });


var tile = d3.geo.tile()
    .size([width, height]);

var projection = d3.geo.mercator()
    .scale((1 << 20) / 2 / Math.PI)
    .translate([-width / 2, -height / 2]);

var circle_color = d3.scale.category10();

//revised: zoom to toronto
var zoom = d3.behavior.zoom()
    .scale(projection.scale() * 2 * Math.PI)
    .scaleExtent([1 << 200, 1 << 25])
    .translate(projection([-79.38558, 43.7020]).map(function (x) {
        return -x;
    }))
    .on("zoom", zoomed);


var container = d3.select("body").append("div")
    .attr("id", "container")
    .style("width", width + "px")
    .style("height", height + "px")
    .style("top", top_offset + "px")
    .style("left", left_offset + "px")
    .call(zoom)
    .on("mousemove", mousemoved); //for coordinates shown on bottom left


var map = container.append("g")
		.attr("id", "map");

var points = container.append("svg")
		.attr("id", "points");

var layer = map.append("div")
    .attr("class", "layer");

var info = map.append("div")
    .attr("class", "info");

var title = d3.select("body")
    .append("div")
    .attr("id","title")
    .style("position", "absolute")
    .style("top", 0 + "px")
    .html('<h1>Toronto Parking Tickets From 2008 to 2015</h1>');

var title_width = (document.getElementById("title").clientWidth + 1);

d3.select("#title")
  .style("left", left_offset+width/2-title_width/2 + "px");



var legend_title = d3.select("body").append("svg")
  	.attr("width", 200)
  	.attr("height", 200)
  	.attr("class","legend_title")
  	.append("text")
  	.attr("x", 40) //adjust positioning
  	.attr("y", 9)
  	.attr("dy", ".35em")
  	.style("text-anchor", "middle")
  	.style("font-weight", "bold")
  	.text("Infraction Type");

var legend = d3.select("body").append("svg")
	.attr("width", 200)
	.attr("height", height)
	.attr("class","legend");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    return "<span>" + d.street_address + "</span>" + "<br />" + "<span>" +
              "Fine Sum: $" + d.fine_sum + "</span>" + "<br />" + "<span>" +
              "Total Tickets: " + d.count + "</span>" + "<br />" + "<span>" +
              "Ticket Cost: $" + d.fine_amt +"<br />" + "</span>" +
              "Infraction Type:" + d.infraction_code + "</span>";
              // "Circle Radius: " + 0.00000000012*d.fine_sum + "</span>";
    // return "<span style='color:black'>" + d.street_address + "</span>";
  });


points.call(tip);
zoomed();


function add_circles(dataset) {
  d3.select("#points").selectAll("circle").data(dataset) //plotted 	locations on map
  .enter()
  .append("circle")
  .attr("class", "parking_spot")
  .attr("cx", function(d) {return projection([d.lng,d.lat])[0]})
  .attr("cy", function(d) {return projection([d.lng,d.lat])[1]})
  .attr("r",1)
	.style("fill", function(d) {return circle_color(d.infraction_code)})
  .on('mouseover', tip.show)
  .on('mouseout', tip.hide);

  // d3.selectAll("circle")
  //     .transition().duration(2000)
  //     .attr("r", function(d) {return rscale(d.fine_sum)*zoom.scale()});

  zoomed();
}


function zoomed() {

  var tiles = tile
      .scale(zoom.scale())
      .translate(zoom.translate())
      ();

  projection
      .scale(zoom.scale() / 2 / Math.PI)
      .translate(zoom.translate());

  var circles = d3.selectAll("circle")
        .attr("cx", function(d) {return projection([d.lng,d.lat])[0]})
				.attr("cy", function(d) {return projection([d.lng,d.lat])[1]})
        // .transition().duration(2000)
        .attr("r", function(d) {return rscale(d.fine_sum)*zoom.scale()});

  var image = layer
      .style(prefix + "transform", matrix3d(tiles.scale, tiles.translate))
    .selectAll(".tile")
      .data(tiles, function(d) { return d; });

  image.exit()
      .remove();

//Ian: play with this to format what OSM gives you...
  image.enter().append("img")
      .attr("class", "tile")
      // .attr("src", function(d) { return "http://" + ["a", "b", "c"][Math.random() * 3 | 0] + ".tile.openstreetmap.org/" + d[2] + "/" + d[0] + "/" + d[1] + ".png"; })
      .attr("src", function(d) { return "http://" + ["a", "b", "c"][Math.random() * 3 | 0] + ".tile.openstreetmap.se/hydda/full/" + d[2] + "/" + d[0] + "/" + d[1] + ".png"; })
      .style("left", function(d) { return (d[0] << 8) + "px"; })
      .style("top", function(d) { return (d[1] << 8) + "px"; });
}

function mousemoved() {
  info.text(projection.invert(d3.mouse(this)));
  info.text(formatLocation(projection.invert(d3.mouse(this)), zoom.scale()));
}

function matrix3d(scale, translate) {
  var k = scale / 256, r = scale % 1 ? Number : Math.round;
  return "matrix3d(" + [k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, r(translate[0] * scale), r(translate[1] * scale), 0, 1 ] + ")";
}

function prefixMatch(p) {
  var i = -1, n = p.length, s = document.body.style;
  while (++i < n) if (p[i] + "Transform" in s) return "-" + p[i].toLowerCase() + "-";
  return "";
}

function formatLocation(p, k) {
  var format = d3.format("." + Math.floor(Math.log(k) / 2 - 2) + "f");
  return (p[1] < 0 ? format(-p[1]) + "째S" : format(p[1]) + "째N") + " "
       + (p[0] < 0 ? format(-p[0]) + "째W" : format(p[0]) + "째E");
}

</script>
